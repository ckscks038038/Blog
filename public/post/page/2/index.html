<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | Lutein 40g</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Lutein 40g">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/post/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css" integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/blog/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/blog/post/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/blog/" accesskey="h" title="Lutein 40g (Alt + H)">Lutein 40g</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/blog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>78. Subsets
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題在school也有寫過，當時還負責主講，沒想到時到今日全都忘光了。這次看neetcode的作法選用DFS，赫然發現這是一個更好的作法。
題目： Given an integer array nums of unique elements, return all possible subsets(the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
* Example 1: Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] * Example 2: Input: nums = [0] Output: [[],[0]] 解題思路： 給定一個list:
arr = [1,2] 用一個暫存的subset來存放當前可能的子集合，每個元素都有兩種選擇，要放入subset或是不要放入。
[] / \ [] [1] / \ / \ [] [2] [1] [1,2] 從上圖可以看出，每一層都是對於一個元素的取捨，從最上面的元素1開始，選擇左邊的路就是不放入當前元素，右邊的路就是放入，最後生成所有可能的子集
1. Base case 因為input是一個array，所以當array走到底時就要跳出，此時也代表走到這條DFS路線上的終點，所以可以將當前的subset加入到res當中...</p>
  </div>
  <footer class="entry-footer">May 17, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 78. Subsets" href="http://localhost:1313/blog/post/leetcode_78/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>297. Serialize and Deserialize Binary Tree
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題用DFS或BFS來做serialize跟deserialize，但因為DFS比較容易想，code也比較少，就選擇用DFS來寫。
題目： Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure....</p>
  </div>
  <footer class="entry-footer">May 17, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 297. Serialize and Deserialize Binary Tree" href="http://localhost:1313/blog/post/leetcode_297/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>124. Binary Tree Maximum Path Sum
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題雖然是hard，但看完山景城跟neetcode的解釋後便頓然開悟，比起前幾題，124反而在解題方向上更明確。 做完這題應該要去做leetcode_543，解題思路幾乎相同。
題目： A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node’s values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path....</p>
  </div>
  <footer class="entry-footer">May 17, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 124. Binary Tree Maximum Path Sum" href="http://localhost:1313/blog/post/leetcode_124/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>105. Construct Binary Tree from Preorder and Inorder Traversal
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題目考研寫過，但只要一步一步想就可以得到結果。這次用遞迴實作才發現其實很難。
題目： Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
* Example 1: Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] * Example 2: Input: preorder = [-1], inorder = [-1] Output: [-1] 解題思路： 先備條件為：所有list中元素都是唯一的。
Preorder list中，第一個元素必定是root node，此時就可以先create一個node作為出發點，繼續生成他的左子樹與右子樹 接著看到Inorder list，可以透過剛剛找到的root node來找出root node在Inorder中的位置(index)，而且這個index非常重要，它代表root node左子樹中所有node的總數量。所以如果index=3，就表示剛剛找到的root node的左子樹一共有三個節點。 在得到index後，回到Preorder，從剛剛建立好的root node往右走index步，就是左子樹於Preorder中最後一個元素，index&#43;1開始接著就都是右子樹的元素了 而此時Inorder中，index&#43;1開始也都是右子樹的元素 1....</p>
  </div>
  <footer class="entry-footer">May 16, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 105. Construct Binary Tree from Preorder and Inorder Traversal" href="http://localhost:1313/blog/post/leetcode_105/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>1448. Count Good Nodes in Binary Tree
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這裡練習DFS的觀念。每次寫DFS都會有新的體會、或想起之前對它的見解，例如這次就想起之前有想到過DFS的遞迴關係其實就只是重複call DFS function，所以理解為每個非null節點都被當作參數call一次DFS
這次又另外了解到，在知道要用DFS來解決問題後，可以先把DFS基本雛型先寫出來(分成process跟iterative call兩部份)，再來改process確切要做什麼、以及iterative call的return value要如何處理。
題目： Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.
Return the number of good nodes in the binary tree.
* Example 1: Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node....</p>
  </div>
  <footer class="entry-footer">May 16, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 1448. Count Good Nodes in Binary Tree" href="http://localhost:1313/blog/post/leetcode_1448/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>199. Binary Tree Right Side View
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題BFS觀念 level order traveral, 學習如何在python中使用deque來解決BFS問題，並且學習在traversal時考慮子節點有null的情況
題目： Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
* Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] * Example 2: Input: root = [1,null,3] Output: [1,3] * Example 3: Input: root = [] Output: [] 解題思路： 如果把樹的每一層都當作一個一維陣列，從上往下、從左往右，每次把traverse到的新節點加入到一維陣列中，並找出一維陣列的最右邊元素(rightSide)，就可以得到結果。
1. 創建deque, 比list更適合 為什麼更適合呢？因為當使用list走完一個level時，需要把已經遍歷的元素pop掉(左邊)，同時前面新訪問到的子節點又需要append(右邊)，因此使用deque就可以用popleft()以及append達成兩個要求。...</p>
  </div>
  <footer class="entry-footer">May 16, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to 199. Binary Tree Right Side View" href="http://localhost:1313/blog/post/leetcode_199/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>110. Balanced Binary Tree
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題被歸類為 easy，但目前一刷完體感上，並沒有很直覺地理解遞迴，要再多 trace 才可以體會 dfs 在這的含意(也可能我還沒有透徹搞懂 dfs)
題目： 給一個 binary tree，回傳該樹是否 balanced
解題思路： 1. 暴力解： 從 root node 開始，算出其左子樹與右子樹的長度，比較兩者長度相減的絕對值是否有&lt;=1，如果有則對其左子樹與右子樹重複此動作直接走完所有 node，否則回傳 False
— 此法可解(參考賈考博)，但因為每次都需要重複走過所有子節點，所以直接複雜度是 O(n^2)。
2. 最優解： 暴力解的思路是由上往下，才會重複 traverse 位於下方的子節點們，那麼這次就從下往上 traverse，這樣每個子節點只需要經過一次，並且往上傳遞兩個資訊:
是否 balanced 高度 對每個子節點而言，都可以把自己視為當前的 root node，然後來檢查自己是否 balanced，以及自己的高度是多少。假設身為 left node，它的高度與 right node 的高度符合 balanced tree 的要求： abs(height[left] - height[right]) &lt;= 1，也保證整棵樹是平衡的，因為 left node 或是 right node 自己可能就是 unbalanced tree(樹高跟是否 balanced 無關唷)。
因此，對於當前的 root node 而言，除了要檢查左右子樹的樹高是否平衡，也要檢查兩者自己本身是否是平衡的。
程式碼： 暴力解： class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if root is None: return True leftHeight = self....</p>
  </div>
  <footer class="entry-footer">April 10, 2023</footer>
  <a class="entry-link" aria-label="post link to 110. Balanced Binary Tree" href="http://localhost:1313/blog/post/leetcode-110/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>TOEFL Preparation Part 1
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 在說一點什麼之前，先上成績！
Date Total Reading Listening Speaking Writing 20220723 62 17 16 15 14 20221029 84 18 26 19 21 20221203 84 19 23 23 19 20230107 86 24 18 22 22 20230211 96 29 23 22 22 其實從2022年初就報名了考試，但因為各種拖延逃避一直到了七月才硬著頭皮考了第一次，基本上只寫過幾回閱讀和聽力，四捨五入就當作裸考，結果也是可想而知的慘烈。接下來又經過了一陣子的自我懷疑、徬徨的低潮期，實際認真開始準備是九月左右，到2023二月的最後一戰，準備時間大概是半年，接下來就分為幾個部份來細說半年來跟托福戰鬥史！
背景 過去一直把自己定義為英文弱底，升學時英文是我最害怕的一個學科，學測的13級分是在補習班每天單字小考加上文法講義硬讀出來的，當時覺得這已經是我的英文極限了(？)上大學後除了原文書外基本上沒有在接觸英文，甚至連多益都沒有考過，大學的英文畢業門檻是用修課抵掉的，因此一戰的62分可以直接當作準備前的程度 。
釐清目的、目標 目的 這次考托福的原因是為了準備出國留學，但不管是什麼原因，決定要考試後就不留任何餘地給自己了！
目標 以留學來說，訂定目標成績的因素有以下幾個：
1. 國家、科系的要求門檻 2. 本身程度 3. 準備時間 我主要申請的國家與領域是美國的Computer Science，大多數查到的建議門檻為100，但考量到有限的時間以及有限的程度，我給自己的目標是95分，最初預期的準備時間為3個月，希望能在2022的12月前解決，可以接著專心準備其他申請文書，但後來的好幾戰又是另一個故事了…
怎麼開始叻 下定決心 首先要知道自己沒有退路，而實際把後路砍斷的方法，就是馬上報名考試！貴到不行的報名費會讓決心蹭蹭的往上升。
蒐集資料 在正式開始唸書之前，可以花個幾天蒐集資料，以下列出幾種必須的內建資料庫：
1. 考試的詳細內容、時長等等資訊 2. 各種備考心得（PTT、Dcard、Medium、Youtube、Bilibili、一畝三分地） 大量去看各種備考心得，在練習的過程中實際去嘗試，找到能有感提升分數的方法。
3. 免費線上課程（Youtube、Bilibili） 若是文章或簡略的方法太過抽象，也可以找到許多英文老師的教學影片，例如實際演練做題、抄筆記、題目講解等，過去許多只能在補習班或付費課程看到的內容，都能在免費的影音平台看到。
練習素材 1. TPO 模擬考題...</p>
  </div>
  <footer class="entry-footer">March 19, 2023 Cindy</footer>
  <a class="entry-link" aria-label="post link to TOEFL Preparation Part 1" href="http://localhost:1313/blog/post/toefl01/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Climbing the Leaderboard
    </h2>
  </header>
  <div class="entry-content">
    <p>前言： 這題來自 HackerRank 的 1 Month Preparation Kit - Week 3，結合了 Leetocde 35. Search Insert Position以及26. Remove Duplicates from Sorted Array兩題的解題套路。
題目： 題目提到的Dense Ranking指在一數組中，重複的數值會獲得一樣的名次 n，且下一個較小的數值會獲得n&#43;1的名次。
解題思路： 以題目給的 input 為例：
ranked = [100, 90, 90, 80] player = [70, 80, 105] 1. 排除重複分數 已知 數組 ranked 中重複的分數獲得的是相同名次，因為有重複分數的緣故，index 與排名無法找出關聯。例如兩個 90 (一個index = 1, 另一個index = 2)在不同的 index 上但排名卻一樣。
如果將數組濃縮為：
ranked = [100, 90, 80] 則各分數在 leaderboard 中的排名剛好等於其所在位置的index&#43;1。例如score = 90對應index = 1，則排名為第二名。這樣一來後續要將 player 的分數加入數組時只需要根據當前index即可算出排名。...</p>
  </div>
  <footer class="entry-footer">March 18, 2023 Yang</footer>
  <a class="entry-link" aria-label="post link to Climbing the Leaderboard" href="http://localhost:1313/blog/post/climbing-the-leaderboard/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/blog/post/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/blog/">Lutein 40g</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
